/*
2.4강 "무치형 (Void type, 보이드)"
엄연한 타입이기 때문에 짚고 넘어가는 것이 좋으며, 무엇보다 포인트를 활용할 때 자주 사용됨.
*/

#include <iostream>

void my_function(void) // = void my_function() : 과거 예제에서 함수를 선언할 때 파라미터가 없다는 의미로 사용했음.
{
	// 또한 {} 사이에 return 타입이 없는 경우에 반드시 사용해주어야 함.
}

int main()
{
	//void my_void; // void는 메모리를 차지하지 않기때문에 선언을 할 수가 없어 error가 발생. 

	int i = 123;
	float f = 123.456f;

	void *my_void; // void *(star)는 주소, 즉 포인터임. 

	// &를 붙이면 주소라는 의미. &i는 정수형 변수의 주소, &f는 실수형 변수의 주소.
	my_void = (void*)&i;
	std::cout << my_void << std::endl; // 0113F7B0
	my_void = (void*)&f;
	std::cout << my_void << std::endl; // 0113F7A4
	/*
	예를 들어 어떤 데이터 타입은 메모리를 적게 차지하여 301호, 302호를 사용하고, 다른 데이터 타입은 많이 차지하여 401호부터 408호까지 사용한다.
	그러나 각각의 데이터 타입의 첫 주소는 결국 301호와 401호로 동일하게 숫자 3개로 표현된다. 즉 첫 주소의 '규격'은 동일하다.

	포인터의 의미: 데이터 타입이 다르고 데이터 타입의 사이즈가 다르더라도 주소를 표현하는 데이터 '양'은 동일하다.
	이와 같이 주소의 데이터 타입은 동일하기 때문에 둘 다 void*로 캐스팅(형변환)이 가능.
	그리고 다시 int의 주소 타입으로 변환하기도하고 float의 주소 타입으로 변환하기도 함.
	*/
	return 0;
}