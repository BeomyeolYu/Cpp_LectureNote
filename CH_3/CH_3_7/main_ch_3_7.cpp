/*
3.7강 "이진수(Binary Numbers)"

- 컴퓨터는 전압을 이용해서 숫자를 구분; 높음(1), 낮음(0).
- 그러나 다수의 bit들을 나열해서 더 크고 복잡한 정보를 다룰 수 있음.
- 수학적인 접근이 강함.
*/

#include <iostream>

int main()
{
	using namespace std;
/********* Topic 1 *********/
	/* 십진수(Decimal)
  ---------
	0 = 0
	1 = 1
	2 = 2
	3 = 3
	4 = 4
	5 = 5
	6 = 6
	7 = 7
	8 = 8
	9 = 9
  ---------
	10 = 10^1 + 0
	11 = 10^1 + 1
	...
	337 = 300 + 30 + 7 = 10^2*3 + 10^1*3 + 10^0*7 
	*/


/********* Topic 2 *********/
	/* 이진수, 숫자가 2개뿐이어서 자릿수가 더 빨리 올라감.
  ---------
	0 = 0
	1 = 1
  ---------
	10 = 2^1*1 + 2^0*0 = 2
	11 = 2^1*1 + 2^0*1 = 3
	*/

	/* 이진수 덧셈
	  (1)       <- 1의 자리에서 1+1로 인한 자릿수 추가.
	   1 1
	+	 1
	--------
	 1 0 0
	*/

/********* Topic 3 *********/
	/* 
	- 사람은 10진수를 사용하므로 이를 입력하면 컴퓨터는 2진수로 변환하여 처리함 (2진수를 바로 입력할 수도 있음).
	- 32 bits = 32 자릿수의 2진수라는 뜻.

	- 2진수의 10진수 변환 방법.
	Q. 0101 1110 : 8 bits
	  (7654 3210 : 자릿수)
	-> 2^7*0 + 2^6*1 + 2^5*0 + 2^4*1 + 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0
	 = 128*0 + 64*1  + 32*0  + 16*1  + 8*1   + 4*1   + 2*1   + 1*0
	 = 0     + 64    + 0     + 16    + 8     + 4     + 2     + 0
	 = 94
	 */

	/* decimal to binary
	- 10진수의 2진수 변환 방법 1. 나눗셈 방법
	Q. 148
	-> 148/2 = 74 r0 (r = remainder; 나머지)
	   74/2  = 37 r0
	   37/2  = 18 r1
	   18/2  = 9 r0
	   9/2   = 4 r1
	   4/2   = 2 r0
	   2/2   = 1 r0
	   1/2   = 0 r1  <- 1을 2로 나누면 몫은 0이고 나머지는 1임.
	-> 1001 0100: 나머지를 역순으로 모은다.

	- 10진수의 2진수 변환 방법 2. 자릿수 방법
	  2진수 자릿수: 1(0) 2(1) 4(2) 8(3) 16(4) 32(5) 64(6) 128(7) 256(8) 512(9) ...
	Q. 148
	  1st,               148 >= 128?  YES -> 128=2^7, 8번째 자릿수의 값이 1
	  2nd, 148-128 = 20, 20  >= 64?   NO  -> 64 =2^6, 7번째 자릿수의 값이 0
	  3rd,               20  >= 32?   NO  -> 32 =2^5, 6번째 자릿수의 값이 0
	  4th,               20  >= 16?   YES -> 16 =2^4, 5번째 자릿수의 값이 1
	  5th, 20-16 = 4,    4   >= 8?    NO  -> 8  =2^3, 4번째 자릿수의 값이 0
	  6th,				 4   >= 4?    YES -> 4  =2^2, 3번째 자릿수의 값이 1
	  7th, 4-4 = 0, <- 0이 나오면 뒷자리수는 모두 0
	-> 1000 0100
	*/


/********* Topic 4 *********/
	/* 이진수끼리의 덧셈.
   (1)(1)
	0  1  1  0 (= 6 in decimal)
  +	0  1  1  1 (= 7 in decimal)
  --------------
	1  1  0  1 (= 13 in decimal)
	*/


/********* Topic 5 *********/
	/* 음의 10진수를 2진수로 변환하는 법.
	Q. -5
	1st, 부호를 제외하고 숫자만 2진수로 변환.
	-> 5 is 0000 0101 in dinary   <- 맨 앞의 수는 부호; +5 = 0.
	2nd, 보수(complement)를 취함.
	-> 1111 1010                  <- 맨 앞의 수는 부호; -5 = 1.
	3rd, 1을 더함.
	-> 1111 1011    
	*/

	/* 1을 더하는 이유.
	- Posivie zero of 8 bits: 0000 0000
	- Negative zero of 8 bits: 1111 1111(complement)
	 -> 0을 표현하는 방법이 2가지가 생김.
	 -> 1을 더하여주어 0000 0000으로 변환.
	*/

	/* 8bits signed int의 10진수 변환
	Q. 1001 1110
	1st, 음수인지 양수인지 체크.
	-> 음수임.
	2nd, 음수라면 complement 취함.
	-> 0110 0001
	3rd, 1을 더함.
	-> 0110 0010
	4th, 10진수로 변환
	-> 98
	5rh, 마이너스 부호 결합
	-> -98
	*/


/********* Topic 6 *********/
	/* "1"001 1110 of signed vs. unsigned
	- unsigned는 128 + ...로 반영되지만 unsigned는 부호를 의미하여 반영되지 않음.
	-> 데이터 타입에 따라 같은 2진수라도 결과에 차이가 있음을 숙지해야 함.

	Q. 1001 1110 of unsigned
	-> 2^7*1 + 2^4*1 + 2^3*1 + 2^2*1 + 2^1*1 = 128 + 16 + 8 + 4 + 2 = 158
	*/

	return 0;
}