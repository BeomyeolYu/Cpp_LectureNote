/*
6.11강 "메모리 동적 할당(Dynamic Memory Allocation) new와 delete"

- 우리가 만든 프로그램에 메모리가 할당되는 것은 3가지 종류로 볼 수 있다.
(1) Static memory allocation(정적 메모리 할당): 전역 변수나 Static 변수와 같이 한번 만들면 메모리를 계속 가지고 있는 종류.
(2) Auto memory allocation(자동 메모리 할당)  : 변수를 선언하거나 정적 배열을 선언했을 때 블록 밖을 나가면 메모리를 OS에 반납하는 종류.
(3) Dynamic memory allocation(동적 메모리 할당): 포인터와 관련지어서 가장 까다로운 종류이다. 
	하지만 사용법을 잘 알아둔다면 여러 가지 중요한 개념을 깨달을 수 있으며, 장기적으로는 라이브러리로 만들어서 편하게 사용할 수 있다.

- new와 delete를 많이 할수록 속도가 느려질 수 있다.
- new와 delete를 해줄 필요가 없는 언어들 또한 존재하지만 C++에서는 이를 이용하여 최적화를 할 수 있다.
*/ 

#include <iostream>
using namespace std;

int main()
{
/**************** Topic 1 ****************/
	// int array[100000000]; 
	/* 위와 같이 정적 배열로 큰 데이터를 생성할 수는 있으나 메모리를 할당할 수 없다는 에러가 발생한다.
	   왜냐하면 정적으로 할당된 메모리는 stack에 들어간다. 그리고 stack은 heap에 비하여 용량이 작다.
	   --> 큰 메모리를 다룰수록 동적 할당을 활용해야 하는 이유: 동적 할당된 메모리는 heap에 들어간다. */

/**************** Topic 2 ****************/
	// OS로부터 메모리를 받아오는 방법 (1)
	int var;
	var = 7;

	// OS로부터 메모리를 받아오는 방법 (2)
	int *ptr = new int; /* 'new int'는 int 사이즈에 맞춰서 OS에게 메모리를 받아온 다음에 그 메모리 주소를 알려준다.
							그렇기 때문에 포인터로 받아줘야 한다. */
	*ptr = 7;

	/* --> 선언과 초기화를 한 번에 하는 방법.
	int *ptr = new int(7);
	int *ptr = new int{ 7 }; */

	cout << ptr << endl;  // 주소 000EB488 출력.
	cout << *ptr << endl; // 7 출력.

/**************** Topic 3 ****************/
	/* 더 중요한 것은 할당받은 메모리를 OS에게 돌려주는 법이다.
	  --> 돌려줘야 하는 이유: 딥러닝, 빅데이터 등을 돌리는 경우 컴퓨터 한대로 감당할 수 없는 메모리(데이터양)를 감당해야 한다.
	  (1) 한 번에 모든 데이터가 메모리에 못 들어갈 수도 있다.
	     --> 일부 데이터의 작업을 끝낸 다음, OS에 돌려줬다가 다른 데이터를 작업할 수 있다.
	  (2) 여러 프로그램들이 동시에 메모리를 요구하면 감당할 수 없다. 
	     --> 우선순위에 따른 지급&반납을 통하여 효율적으로 사용할 수 있다. */

	// 실제로는 OS가 프로그램이 실행되면 메모리를 지급해주고, 실행이 끝나면 메모리를 자동으로 걷어간다. 
	delete ptr; // 메모리를 자진 반납하는 방법.

	/* 주의할 점.
	cout << "After delete" << endl;
	cout << ptr << endl;  // 주소는 그대로 남아있다 (000EB488 출력). 
	cout << *ptr << endl; // 그러나 옛 고향 주소를 따라 집에 도착했으나 다른 집이었다 (-572662307 출력). */

	// 해결 방법; delete 후에 nullptr을 선언한다.
	ptr = nullptr; // '포인터가 가지고 있는 주소는 아무 의미가 없는 값이에요'라고 표시해두는 것.
	if (ptr != nullptr) // = if (ptr): ptr이 의미가 있는 경우에만 cout을 출력하도록.
	{
		cout << ptr << endl;  
		cout << *ptr << endl;
	}
	// 그러나 스마트 포인터를 익히면 이와 같은 경우를 방지할 수 있다.

/**************** Topic 4 ****************/
	/* 다른 프로그램이 모든 메모리를 사용하고 있어서 메모리를 할당받지 못하는 경우가 있다.
	   시나리오 1) 프로그램이 죽게 내버려둔다.
	   시나리오 2) 프로그램이 죽지 않게 살려두었다가 다른 프로그램이 끝나면 메모리를 받도록 만든다. */

	int *ptr1 = new (std::nothrow) int{ 7 }; // new가 죽지 않고 버티도록 만들어주는 법.
	if (ptr1 != nullptr) // 안전장치를 추가해둘 수 있다.
	{
		cout << ptr1 << endl;
		cout << *ptr1 << endl;
	}
	else
	{
		cout << "Could not allocation memory" << endl;
	}

/**************** Topic 5 ****************/
	/* memory leak(메모리 누수)라는 무시무시한 상황.
	  --> OS로부터 메모리는 받는데 쓰이지는 않고 계속 쌓이는데 어디 있는지도 모르는 경우. */

	while (true) 
	{
		int *ptr2 = new int; // ptr2이 new를 한다. 
		cout << ptr2 << endl;
		// 사용하지도 않고 delete도 하지 않는다.
	}
	// 작업 관리자에서 메모리가 무한히 상승하면 memory leak을 의심할 수 있다.

	return 0;
}